/*
Copyright 2022 The Koordinator Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
//

// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/koordlet/metriccache/tsdb_storage.go

// Package mock_metriccache is a generated GoMock package.
package mock_metriccache

import (
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
	metriccache "github.com/koordinator-sh/koordinator/pkg/koordlet/metriccache"
)

// MockTSDBStorage is a mock of TSDBStorage interface.
type MockTSDBStorage struct {
	ctrl     *gomock.Controller
	recorder *MockTSDBStorageMockRecorder
}

// MockTSDBStorageMockRecorder is the mock recorder for MockTSDBStorage.
type MockTSDBStorageMockRecorder struct {
	mock *MockTSDBStorage
}

// NewMockTSDBStorage creates a new mock instance.
func NewMockTSDBStorage(ctrl *gomock.Controller) *MockTSDBStorage {
	mock := &MockTSDBStorage{ctrl: ctrl}
	mock.recorder = &MockTSDBStorageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTSDBStorage) EXPECT() *MockTSDBStorageMockRecorder {
	return m.recorder
}

// Appender mocks base method.
func (m *MockTSDBStorage) Appender() metriccache.Appender {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Appender")
	ret0, _ := ret[0].(metriccache.Appender)
	return ret0
}

// Appender indicates an expected call of Appender.
func (mr *MockTSDBStorageMockRecorder) Appender() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Appender", reflect.TypeOf((*MockTSDBStorage)(nil).Appender))
}

// Close mocks base method.
func (m *MockTSDBStorage) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockTSDBStorageMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockTSDBStorage)(nil).Close))
}

// Querier mocks base method.
func (m *MockTSDBStorage) Querier(startTime, endTime time.Time) (metriccache.Querier, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Querier", startTime, endTime)
	ret0, _ := ret[0].(metriccache.Querier)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Querier indicates an expected call of Querier.
func (mr *MockTSDBStorageMockRecorder) Querier(startTime, endTime interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Querier", reflect.TypeOf((*MockTSDBStorage)(nil).Querier), startTime, endTime)
}

// MockAppendable is a mock of Appendable interface.
type MockAppendable struct {
	ctrl     *gomock.Controller
	recorder *MockAppendableMockRecorder
}

// MockAppendableMockRecorder is the mock recorder for MockAppendable.
type MockAppendableMockRecorder struct {
	mock *MockAppendable
}

// NewMockAppendable creates a new mock instance.
func NewMockAppendable(ctrl *gomock.Controller) *MockAppendable {
	mock := &MockAppendable{ctrl: ctrl}
	mock.recorder = &MockAppendableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAppendable) EXPECT() *MockAppendableMockRecorder {
	return m.recorder
}

// Appender mocks base method.
func (m *MockAppendable) Appender() metriccache.Appender {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Appender")
	ret0, _ := ret[0].(metriccache.Appender)
	return ret0
}

// Appender indicates an expected call of Appender.
func (mr *MockAppendableMockRecorder) Appender() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Appender", reflect.TypeOf((*MockAppendable)(nil).Appender))
}

// MockAppender is a mock of Appender interface.
type MockAppender struct {
	ctrl     *gomock.Controller
	recorder *MockAppenderMockRecorder
}

// MockAppenderMockRecorder is the mock recorder for MockAppender.
type MockAppenderMockRecorder struct {
	mock *MockAppender
}

// NewMockAppender creates a new mock instance.
func NewMockAppender(ctrl *gomock.Controller) *MockAppender {
	mock := &MockAppender{ctrl: ctrl}
	mock.recorder = &MockAppenderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAppender) EXPECT() *MockAppenderMockRecorder {
	return m.recorder
}

// Append mocks base method.
func (m *MockAppender) Append(s []metriccache.MetricSample) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Append", s)
	ret0, _ := ret[0].(error)
	return ret0
}

// Append indicates an expected call of Append.
func (mr *MockAppenderMockRecorder) Append(s interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Append", reflect.TypeOf((*MockAppender)(nil).Append), s)
}

// Commit mocks base method.
func (m *MockAppender) Commit() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockAppenderMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockAppender)(nil).Commit))
}

// MockQueryable is a mock of Queryable interface.
type MockQueryable struct {
	ctrl     *gomock.Controller
	recorder *MockQueryableMockRecorder
}

// MockQueryableMockRecorder is the mock recorder for MockQueryable.
type MockQueryableMockRecorder struct {
	mock *MockQueryable
}

// NewMockQueryable creates a new mock instance.
func NewMockQueryable(ctrl *gomock.Controller) *MockQueryable {
	mock := &MockQueryable{ctrl: ctrl}
	mock.recorder = &MockQueryableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQueryable) EXPECT() *MockQueryableMockRecorder {
	return m.recorder
}

// Querier mocks base method.
func (m *MockQueryable) Querier(startTime, endTime time.Time) (metriccache.Querier, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Querier", startTime, endTime)
	ret0, _ := ret[0].(metriccache.Querier)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Querier indicates an expected call of Querier.
func (mr *MockQueryableMockRecorder) Querier(startTime, endTime interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Querier", reflect.TypeOf((*MockQueryable)(nil).Querier), startTime, endTime)
}

// MockQuerier is a mock of Querier interface.
type MockQuerier struct {
	ctrl     *gomock.Controller
	recorder *MockQuerierMockRecorder
}

// MockQuerierMockRecorder is the mock recorder for MockQuerier.
type MockQuerierMockRecorder struct {
	mock *MockQuerier
}

// NewMockQuerier creates a new mock instance.
func NewMockQuerier(ctrl *gomock.Controller) *MockQuerier {
	mock := &MockQuerier{ctrl: ctrl}
	mock.recorder = &MockQuerierMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQuerier) EXPECT() *MockQuerierMockRecorder {
	return m.recorder
}

// Query mocks base method.
func (m *MockQuerier) Query(meta metriccache.MetricMeta, hints *metriccache.QueryHints, result metriccache.MetricResult) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Query", meta, hints, result)
	ret0, _ := ret[0].(error)
	return ret0
}

// Query indicates an expected call of Query.
func (mr *MockQuerierMockRecorder) Query(meta, hints, result interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockQuerier)(nil).Query), meta, hints, result)
}
