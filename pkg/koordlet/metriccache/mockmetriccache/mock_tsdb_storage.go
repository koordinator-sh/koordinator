// /*
// Copyright 2022 The Koordinator Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// */
//

// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/koordlet/metriccache/tsdb_storage.go

// Package mock_metriccache is a generated GoMock package.
package mock_metriccache

import (
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
	metriccache "github.com/koordinator-sh/koordinator/pkg/koordlet/metriccache"
)

// MockTSDBStorage is a mock of TSDBStorage interface.
type MockTSDBStorage struct {
	ctrl     *gomock.Controller
	recorder *MockTSDBStorageMockRecorder
}

// MockTSDBStorageMockRecorder is the mock recorder for MockTSDBStorage.
type MockTSDBStorageMockRecorder struct {
	mock *MockTSDBStorage
}

// NewMockTSDBStorage creates a new mock instance.
func NewMockTSDBStorage(ctrl *gomock.Controller) *MockTSDBStorage {
	mock := &MockTSDBStorage{ctrl: ctrl}
	mock.recorder = &MockTSDBStorageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTSDBStorage) EXPECT() *MockTSDBStorageMockRecorder {
	return m.recorder
}

// Appender mocks base method.
func (m *MockTSDBStorage) Appender() metriccache.Appender {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Appender")
	ret0, _ := ret[0].(metriccache.Appender)
	return ret0
}

// Appender indicates an expected call of Appender.
func (mr *MockTSDBStorageMockRecorder) Appender() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Appender", reflect.TypeOf((*MockTSDBStorage)(nil).Appender))
}

// Close mocks base method.
func (m *MockTSDBStorage) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockTSDBStorageMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockTSDBStorage)(nil).Close))
}

// Querier mocks base method.
func (m *MockTSDBStorage) Querier(startTime, endTime time.Time) (metriccache.Querier, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Querier", startTime, endTime)
	ret0, _ := ret[0].(metriccache.Querier)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Querier indicates an expected call of Querier.
func (mr *MockTSDBStorageMockRecorder) Querier(startTime, endTime interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Querier", reflect.TypeOf((*MockTSDBStorage)(nil).Querier), startTime, endTime)
}

// MockAppendable is a mock of Appendable interface.
type MockAppendable struct {
	ctrl     *gomock.Controller
	recorder *MockAppendableMockRecorder
}

// MockAppendableMockRecorder is the mock recorder for MockAppendable.
type MockAppendableMockRecorder struct {
	mock *MockAppendable
}

// NewMockAppendable creates a new mock instance.
func NewMockAppendable(ctrl *gomock.Controller) *MockAppendable {
	mock := &MockAppendable{ctrl: ctrl}
	mock.recorder = &MockAppendableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAppendable) EXPECT() *MockAppendableMockRecorder {
	return m.recorder
}

// Appender mocks base method.
func (m *MockAppendable) Appender() metriccache.Appender {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Appender")
	ret0, _ := ret[0].(metriccache.Appender)
	return ret0
}

// Appender indicates an expected call of Appender.
func (mr *MockAppendableMockRecorder) Appender() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Appender", reflect.TypeOf((*MockAppendable)(nil).Appender))
}

// MockAppender is a mock of Appender interface.
type MockAppender struct {
	ctrl     *gomock.Controller
	recorder *MockAppenderMockRecorder
}

// MockAppenderMockRecorder is the mock recorder for MockAppender.
type MockAppenderMockRecorder struct {
	mock *MockAppender
}

// NewMockAppender creates a new mock instance.
func NewMockAppender(ctrl *gomock.Controller) *MockAppender {
	mock := &MockAppender{ctrl: ctrl}
	mock.recorder = &MockAppenderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAppender) EXPECT() *MockAppenderMockRecorder {
	return m.recorder
}

// Append mocks base method.
func (m *MockAppender) Append(s []metriccache.MetricSample) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Append", s)
	ret0, _ := ret[0].(error)
	return ret0
}

// Append indicates an expected call of Append.
func (mr *MockAppenderMockRecorder) Append(s interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Append", reflect.TypeOf((*MockAppender)(nil).Append), s)
}

// Commit mocks base method.
func (m *MockAppender) Commit() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockAppenderMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockAppender)(nil).Commit))
}

// MockQueryable is a mock of Queryable interface.
type MockQueryable struct {
	ctrl     *gomock.Controller
	recorder *MockQueryableMockRecorder
}

// MockQueryableMockRecorder is the mock recorder for MockQueryable.
type MockQueryableMockRecorder struct {
	mock *MockQueryable
}

// NewMockQueryable creates a new mock instance.
func NewMockQueryable(ctrl *gomock.Controller) *MockQueryable {
	mock := &MockQueryable{ctrl: ctrl}
	mock.recorder = &MockQueryableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQueryable) EXPECT() *MockQueryableMockRecorder {
	return m.recorder
}

// Querier mocks base method.
func (m *MockQueryable) Querier(startTime, endTime time.Time) (metriccache.Querier, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Querier", startTime, endTime)
	ret0, _ := ret[0].(metriccache.Querier)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Querier indicates an expected call of Querier.
func (mr *MockQueryableMockRecorder) Querier(startTime, endTime interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Querier", reflect.TypeOf((*MockQueryable)(nil).Querier), startTime, endTime)
}

// MockQuerier is a mock of Querier interface.
type MockQuerier struct {
	ctrl     *gomock.Controller
	recorder *MockQuerierMockRecorder
}

// MockQuerierMockRecorder is the mock recorder for MockQuerier.
type MockQuerierMockRecorder struct {
	mock *MockQuerier
}

// NewMockQuerier creates a new mock instance.
func NewMockQuerier(ctrl *gomock.Controller) *MockQuerier {
	mock := &MockQuerier{ctrl: ctrl}
	mock.recorder = &MockQuerierMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQuerier) EXPECT() *MockQuerierMockRecorder {
	return m.recorder
}

// Query mocks base method.
func (m *MockQuerier) Query(meta metriccache.MetricMeta, hints *metriccache.QueryHints, result metriccache.MetricResult) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Query", meta, hints, result)
	ret0, _ := ret[0].(error)
	return ret0
}

// Query indicates an expected call of Query.
func (mr *MockQuerierMockRecorder) Query(meta, hints, result interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockQuerier)(nil).Query), meta, hints, result)
}
